Great! Hereâ€™s your **complete, polished manual** â€” ready to drop into your project as `README.md` or documentation.

It includes:

âœ… Contents âœ… Project structure âœ… Classification rules âœ… Naming conventions âœ… Commenting and function tracking âœ… Best practices âœ… Examples âœ… Glossary

---

# ðŸ“– Bitburner DDD + FP Project Manual & Template

---

## ðŸ“š Contents

1. [Introduction](#introduction)
2. [Project Structure](#project-structure)
3. [Classification Guide](#classification-guide)
4. [Naming Conventions](#naming-conventions)
5. [Folder & File Template](#folder--file-template)
6. [Naming Guidelines](#naming-guidelines)
7. [Commenting & Function Tracking](#commenting--function-tracking)
8. [Best Practices](#best-practices)
9. [Examples](#examples)
10. [Glossary](#glossary)

---

## ðŸ”° Introduction

This manual helps you structure Bitburner scripts using a **Domain-Driven Design (DDD)** + **Functional Programming (FP)** hybrid architecture.

It provides folder layout, classification rules, naming conventions, commenting guidelines, best practices, and example code to keep your project clean, maintainable, and efficient.

---

## ðŸ—ï¸ Project Structure

```
/src
  â”œâ”€â”€ app/         â†’ Application layer (orchestration, workflows)
  â”œâ”€â”€ domain/      â†’ Domain layer (pure business logic, models)
  â”œâ”€â”€ infra/       â†’ Infrastructure layer (ns API, filesystem, external deps)
  â”œâ”€â”€ shared/      â†’ Shared utilities (types, helpers, constants)
  â”œâ”€â”€ tests/       â†’ âœ… Test scripts for all layers
  â””â”€â”€ main.js      â†’ Entry point

```

ðŸ“ /src This is your main source code folder â€” all your project code lives here.

Inside it, we divide things into four layers:

1ï¸âƒ£ /src/app/ â†’ Application layer What it does: Orchestrates workflows and coordinates tasks between domain + infrastructure.

Example role:

Calls domain functions to plan hacks.

Uses infra functions to interact with the Bitburner ns API.

Controls the overall hacking flow.

Example file: HackOrchestrator.js â†’ runs the full hack cycle.

2ï¸âƒ£ /src/domain/ â†’ Domain layer What it does: Holds your core business logic â€” pure functions and models that donâ€™t rely on external stuff like ns or the filesystem.

Why important: Itâ€™s testable, reusable, and independent of Bitburner APIs.

Example file: HackPlanner.js â†’ plans which servers to hack and how.

3ï¸âƒ£ /src/infra/ â†’ Infrastructure layer What it does: Handles interactions with external dependencies:

Bitburnerâ€™s ns API

the filesystem

network or hardware

Why important: It isolates side effects so your domain logic stays clean.

Example file: NsServerScanner.js â†’ scans servers using ns.scan().

4ï¸âƒ£ /src/shared/ â†’ Shared utilities What it does: Holds general-purpose helpers, types, constants, or utilities that are reused across multiple layers.

Why important: Prevents duplicating helpers in multiple places.

Example file: LoggerUtil.js â†’ formats log messages; Constants.js â†’ stores project-wide constants.

5ï¸âƒ£ main.js â†’ Entry point What it does: This is the script you run in Bitburner (run main.js) â€” it typically loads the app layer or kicks off the main workflow.

ðŸ“Š Visual Summary Folder Responsibility Examples app/ Orchestration, workflow control HackOrchestrator.js domain/ Pure logic, core calculations HackPlanner.js, ServerAnalyzer.js infra/ External API / ns / filesystem interaction NsServerScanner.js shared/ Common utilities, constants, types LoggerUtil.js, Constants.js main.js Top-level entry script Boots up everything

âœ… Why this structure helps Keeps your pure logic separate from messy APIs.

Makes it easier to test core logic without ns.

Helps you scale projects as they grow.

Encourages modular, maintainable code.

---

## âš–ï¸ Classification Guide

| Layer          | Description                                | Questions to Ask                 |
| -------------- | ------------------------------------------ | -------------------------------- |
| Domain         | Pure logic, no side effects                | Works without ns? Pure function? |
| Application    | Orchestration, coordinates domain + infra  | Does it manage flow?             |
| Infrastructure | Talks to ns, filesystem, hardware, network | Does it depend on external APIs? |
| Shared         | General utilities, types, constants        | Is it reusable across layers?    |

---

## ðŸ·ï¸ Naming Conventions

| Layer          | Example Files                         |
| -------------- | ------------------------------------- |
| Domain         | `ServerAnalyzer.js`, `HackPlanner.js` |
| Application    | `HackOrchestrator.js`                 |
| Infrastructure | `NsServerScanner.js`                  |
| Shared         | `LoggerUtil.js`, `TypeDefs.js`        |

---

## ðŸ—‚ï¸ Folder & File Template

```
/src
â”œâ”€â”€ app/
â”‚   â””â”€â”€ HackOrchestrator.js
â”œâ”€â”€ domain/
â”‚   â”œâ”€â”€ ServerAnalyzer.js
â”‚   â””â”€â”€ HackPlanner.js
â”œâ”€â”€ infra/
â”‚   â””â”€â”€ NsServerScanner.js
â”œâ”€â”€ shared/
â”‚   â”œâ”€â”€ LoggerUtil.js
â”‚   â””â”€â”€ TypeDefs.js
â””â”€â”€ main.js
```

---

## ðŸ“ Naming Guidelines

| Item     | Style                                 | Example                          |
| -------- | ------------------------------------- | -------------------------------- |
| Function | camelCase + verb                      | `calculateHackChance()`          |
| Class    | PascalCase + noun                     | `ServerInfo`                     |
| File     | PascalCase, match export              | `HackPlanner.js` â†’ `planHacks()` |
| Variable | camelCase or UPPER_SNAKE_CASE (const) | `maxThreads`, `DEFAULT_DELAY`    |

- **Functions** â†’ verbs: `scanServers()`, `planHacks()`
- **Classes** â†’ nouns: `ServerInfo`, `HackPlan`
- **Files** â†’ match export name, PascalCase
- **Variables** â†’ meaningful names, camelCase; constants in UPPER_SNAKE_CASE

---

## ðŸ—¨ï¸ Commenting & Function Tracking

### ðŸ“Œ When to Use Comments

âœ… Top of each file â†’ explain its purpose âœ… Above complex functions â†’ what it does, why it matters âœ… Inside tricky logic â†’ why (not what) âœ… Mark deprecated, TODO, or improvements:

```js
// TODO: Optimize for batch hacking
// DEPRECATED: Use scanAllServers() in shared/NetworkUtil.js
```

---

### ðŸ“Š Tracking Function Usage

âœ… **Mark deprecated code** with comments âœ… **Search for usage** using editor tools or `grep` / `ripgrep` âœ… **Maintain a functions map** in `/docs/functions.md`:

```
| Function            | Purpose                | Status       |
|---------------------|------------------------|--------------|
| planHacks()         | Plan hacking targets   | Active       |
| scanServers()       | Scan all servers       | Replaced     |
```

âœ… **Use ESLint or editor warnings** to detect unused code

---

## ðŸŒŸ Best Practices

### ðŸ§© 1. Keep domain logic pure

No side effects, no ns calls â†’ testable, reusable.

### âš¡ 2. Minimize global state

Pass data explicitly, avoid hidden dependencies.

### ðŸš€ 3. Keep scripts small and focused

Do one thing well â†’ split big flows into smaller modules.

### ðŸ”„ 4. Favor composition over duplication

Build big flows from small, reusable functions.

### ðŸ“‚ 5. Keep folders and files organized

Stick to app/domain/infra/shared; no dumping in root.

### ðŸ“‘ 6. Document important decisions

Use file-level comments and maintain `/docs`.

### ðŸ›¡ï¸ 7. Write defensive code

Handle empty arrays, nulls, unexpected inputs.

### ðŸ§ª 8. Test pure functions

Write small test scripts or assertions for domain logic.

### ðŸ§¹ 9. Regularly clean up unused code

Mark deprecated code, clean up dead code.

### âš™ï¸ 10. Optimize for RAM (Bitburner-specific)

Separate high-RAM functions; use `ns.exec()` when needed.

---

## ðŸ’¡ Examples

### app/HackOrchestrator.js

```js
import { planHacks } from '/src/domain/HackPlanner.js';
import { scanServers } from '/src/infra/NsServerScanner.js';

export async function runHackFlow(ns) {
  const servers = scanServers(ns);
  const plans = planHacks(servers);
  for (const plan of plans) {
    await ns.hack(plan.target);
  }
}
```

---

### domain/HackPlanner.js

```js
/**
 * Plans hacking targets based on server info.
 * @param {ServerInfo[]} servers
 * @returns {HackPlan[]}
 */
export function planHacks(servers) {
  return servers.filter((s) => s.moneyMax > 0).map((s) => ({ target: s.hostname, threads: 10 }));
}
```

---

### shared/LoggerUtil.js

```js
export function logMessage(ns, message) {
  ns.tprint(`[LOG] ${message}`);
}
```

---

## ðŸ“– Glossary

| Term          | Meaning                                             |
| ------------- | --------------------------------------------------- |
| DDD           | Domain-Driven Design â†’ business logic centered      |
| FP            | Functional Programming â†’ pure, composable functions |
| Pure Function | Same output for same input, no side effects         |
| ns            | Bitburnerâ€™s Netscript API object                    |
| DEPRECATED    | Marked as outdated, to be removed                   |
| TODO          | Work or improvements to be done later               |

---

## âœ… Summary Checklist

âœ… Use app/domain/infra/shared folders âœ… Classify code with the guide âœ… Name functions, files, and variables consistently âœ… Write useful, minimal comments âœ… Track deprecated/unused functions âœ… Follow best practices âœ… Optimize for Bitburnerâ€™s RAM constraints

---

### ðŸ“¦ Bonus Tools (optional)

- `/docs/functions.md` â†’ track active, deprecated, or replaced functions
- `.eslintrc.js` â†’ enable linting for unused code, bad practices
- `README.md` â†’ summarize project purpose, architecture, and setup

---
